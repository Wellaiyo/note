---
layout: post
title: 'javascript内存泄露'
date: 2016-01-01
tags: 'javascript'
---

经常会在前端技术交流群中看到“内存泄露”这个词，然后会想，前端内存泄露是指什么？那会是怎样一种场景？

javascript的内存管理是基于javascript的回收机制来实现的，这我是知道的，比如定义一个变量，在使用完毕后，该变量会被回收。而如果被引用或者存在于一个引用链中，就会存在于内存中。同样在闭包中，变量也不会直接被回收，这使得我们可以利用闭包来实现一些特定的功能，在[javascript中的闭包](http://dev-note.cn/2015/05/the-closure-in-javascript)一文有提到。

那么什么是内存泄露呢？

当一个对象不再被引用，但是浏览器由于某些原因并没有释放内存，这时就会引起内存泄露。浏览器问题，浏览器插件引起的问题，甚至是我们编写的代码问题都可能引起内存泄露。比如，在IE8以下时，dom对象的循环引用就会引起内存泄露。

javascript的垃圾回收机制本身并没有问题，但浏览器在为DOM对象分配和恢复内存的方式上却有些出入。

IE和FF均使用引用计数来为DOM对象处理内存。在引用计数系统，每个所引用的对象都会保留一个计数，以获悉有多少对象正在引用它。如果计数为零，该对象就会被销毁，其占用的内存也会返回给堆。虽然这种解决方案总的来说还算有效，但在循环引用方面却存在一些盲点。

当两个对象互相引用时，就构成了循环引用，其中每个对象的引用计数值都被赋为1。在纯垃圾收集系统中，循环引用问题不大。若涉及到的两个对象中的一个对象被任何其他对象引用，那么这两个对象都将被回收。而在引用计数系统，这两个对象都不能被销毁，原因是引用计数永远不能为零。在同时使用了回收和引用计数的混合系统中，将会发生泄漏，因为系统不能正确识别循环引用。在这种情况下，DOM 对象和 JavaScript 对象均不能被销毁。

	function Handler(){
		var ele = document.getElementById('testId');
		ele.onclick = function (e){ //do something };
	}


在IE中，防止内存泄露的办法就是打破循环引用

	function Handler(){
		var ele = document.getElementById('testId');
		ele.onclick = function (e){ //do something };
		ele = null;
	}

将DOM元素调用过后赋值为null，onclick事件中就不会在引用elel，因为这个循环被打破了。

可以通过chrome开发者工具栏中的Timeline来不完全检测内存的泄露。

> 关于内存泄露的种种，[这篇文章](http://web.jobbole.com/82080/)介绍得比较全面，推荐细看！
